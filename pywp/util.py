
from typing import List
import numpy as np

class Grid:
    """ N-dimensional grid manipulations.
    """

    def __init__(self, *args):
        """ Constructs an N-dimensional grid. For each dimension, it can be either a number
        (specifying it's a fixed constant) or a real grid.

        It's recommended to use `pywp.util.mgrid[slices or indices]` to create the Grid instance. For example,
        ```
            pywp.util.mgrid[1:2, 3:4]
            pywp.util.mgrid[1:2, 3, 4:10:1j]
        ```

        Args can be:
            - a single list of slices/floats. For slices, a complex number means length instead of stride.
            - slices/floats. Same as above.
            - two lists (for compatibility). The first one is a list of tuples (start,end), and the second one 
                is a list of lengths.
        """

        # compatibility
        if len(args) == 2 and not isinstance(args[0], slice):
            self.box = list(args[0])
            if isinstance(args[1], int):
                self.ngrid = [args[1]] * len(self.box)
            else:
                assert len(args[1]) == len(self.box)
                self.ngrid = list(args[1])
            self.is_griding_direction = [not isinstance(b, (float, int, complex)) for b in self.box]

        else:
            
            if len(args) == 1 and not isinstance(args[0], (slice, float, int, complex)):
                args = args[0]

            self.box = []
            self.ngrid = []
            self.is_griding_direction = []

            for a in args:
                if isinstance(a, slice):
                    if isinstance(a.step, complex):
                        self.box.append((a.start, a.stop))
                        self.ngrid.append(int(a.step.imag))
                    elif a.step is None:
                        self.box.append((a.start, a.stop))
                        self.ngrid.append(1)
                    else: # it's a range instead of linspace
                        self.ngrid.append(int((a.stop - a.start)/a.step))
                        self.box.append((a.start, a.start + self.ngrid[-1]*a.step ))
                    self.is_griding_direction.append(True)
                else:
                    self.box.append(a)
                    self.ngrid.append(1)
                    self.is_griding_direction.append(False)

    @property
    def shape(self):
        return tuple(self.ngrid)
    
    @property
    def ndim(self):
        return len(self.box)

    def build(self, return_scalar:bool=True) -> List[np.ndarray]:
        """ Build the grid dense grid as if generated by `np.meshgrid(order='ij')`.
        
        return_scalar: If True, then for non-griding directions, returns a number instead of
            an array filled with that number.
        """
        inputs = []
        for j in range(len(self.box)):
            if self.is_griding_direction[j]:
                inputs.append(np.linspace(self.box[j][0], self.box[j][1], self.ngrid[j]))
            else:
                inputs.append(np.array([self.box[j]]))
        
        outputs = np.meshgrid(*inputs, indexing='ij')
        if return_scalar:
            return [outputs[j] if self.is_griding_direction[j] else self.box[j] for j in range(len(self.box))]
        else:
            return outputs
        
    def build_individual(self) -> List[np.ndarray]:
        """ Returns a list of 1D arrays, describing the grids for each dimension as if generated by `np.linspace()`.
        """
        inputs = []
        for j in range(len(self.box)):
            if self.is_griding_direction[j]:
                inputs.append(np.linspace(self.box[j][0], self.box[j][1], self.ngrid[j]))
            else:
                inputs.append(np.array([self.box[j]]))
        return inputs

    def dx(self, return_all:bool=False):
        """ Return an array of grid spacing at each dimension.

        return_all: If `True`, will return `None' for non-griding directions. Otherwise will only return griding directions.
        """
        if return_all:
            return [
                (self.box[j][1] - self.box[j][0])/self.ngrid[j] if self.is_griding_direction[j] else None
                for j in range(len(self.box))]
        else:
            return [
                (self.box[j][1] - self.box[j][0])/self.ngrid[j] for j in range(len(self.box)) if self.is_griding_direction[j]]

    def extent(self, return_all:bool=False):
        """ Return a list lbound1, rbound1, lbound2, .... Useful for graphic purposes.

        return_all: If `True', will return all directions. Otherwise only griding directions are returned.
        """
        ext = []
        if return_all:
            for j in range(len(self.box)):
                ext += [self.box[j][0], self.box[j][1]] if self.is_griding_direction[j] else [self.box[j], self.box[j]]                    
        else:
            for j in range(len(self.box)):
                if self.is_griding_direction[j]:
                    ext += [self.box[j][0], self.box[j][1]]
        return ext


class _GridCreator:
    def __getitem__(self, *indices) -> Grid:
        return Grid(*indices)

mgrid = _GridCreator()

def adiabatic_surface(Hel:np.ndarray):
    """ Get adiabatic energies.
    Hel: (... x 2 x 2) array.
    Returns: (... x 2) array.
    """
    return np.linalg.eigvalsh(Hel)


def adiabat(Hel:np.ndarray):
    """ Get adiabatic energies and states.
    Hel: (... x 2 x 2) array.
    Returns: 
        E: (... x 2) array.
        U: (... x 2 x 2) array.
    """
    return np.linalg.eigh(Hel)


def gradient(Hel:np.ndarray, dx, direction='all'):
    """ A simple wrapper around np.gradient().
    Hel: (... x 2 x 2) array.
    dx: float/list[float]. The grid size on each direction.
    direction: 'all' or list[int] specifying the directions.

    Returns: list[ndarray], each being the gradient on one direction.
    """
    if direction == 'all':
        direction = tuple(range(Hel.ndim-2))

    if isinstance(dx, (int, float)):
        dx = [dx] * len(direction)

    deltaH = []

    for d, dx_ in zip(direction, dx):
        deltaH.append(
            np.gradient(Hel, dx_, axis=d)
        )

    return deltaH


def drv_coupling_hf(deltaH:list, E:np.ndarray, U:np.ndarray):
    """ Calculate derivative coupling by Hellmann-Feynmann theory.
    deltaH: list[ndarray]. Gradient of Hamiltonian (in one or more directions).
    E, U: Energy and adiabatic states.

    Returns: list[ndarray], each being the derivative coupling on one direction.
    """

    drv_coupling = []
    invE = np.empty(U.shape)
    for j in range(E.shape[-1]):
        for k in range(E.shape[-1]):
            if j == k:
                invE[..., j, k].fill(0)
            else:
                invE[..., j, k] = 1/(E[..., k] - E[..., j])

    for dh in deltaH:
        dc = np.empty(dh.shape, dtype=complex)
        for index in np.ndindex(U.shape[:-2]):
            dc[index] = (U[index].T @ dh[index] @ U[index])*invE[index]
        drv_coupling.append(dc)

    return drv_coupling


def expm_batch(M:np.ndarray, dt:float):
    """ Calculating exp(-1j*M*dt).
    """
    D, U = np.linalg.eigh(M)
    DD = np.zeros_like(U, dtype=complex)
    for j in range(D.shape[-1]):
        DD[..., j, j] = np.exp(-1j*dt*D[..., j])

    nk = len(U.shape)-2
    tp_index = list(range(nk)) + [nk+1, nk]
    return U @ DD @ np.conj(np.transpose(U, tp_index))
    

def project_wavefunction(psi:np.ndarray, U:np.ndarray, inverse=False):
    if inverse:
        return (psi[..., None, :] @ np.conj(U))[..., 0, :]
    else:
        return (U @ psi[..., None])[..., 0]

