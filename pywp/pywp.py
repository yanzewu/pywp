
import numpy as np 
import itertools
from .potential import Potential
from .util import expm_batch, Grid
from typing import Union, List, Callable, Any
from dataclasses import dataclass
from types import ModuleType

def abs2(x):
    return (x * x.conj()).real

@dataclass
class PhysicalParameter:
    """ Represents physical parameters and operator caches.
    """
    Psi: np.ndarray     # Initial wavefunction
    H: np.ndarray       # Hamiltonian 
    KE: np.ndarray      # Kinetic Operator
    TU: np.ndarray      # exp(-1j*dt*KE)
    VU: np.ndarray      # exp(-1j*dt*H)
    VUhalf: np.ndarray  # exp(-1j*dt*H/2)
    VUhalfinv: np.ndarray   # exp(+1j*dt*H/2)
    R: list[np.ndarray]     # R grid, generated by meshgrid('ij')
    K: list[np.ndarray]     # K grid, 
    dA: float           # Volume of an R-cell
    dK: float           # Volume of a K-cell
    dt: float           # timestep
    

@dataclass
class CheckPoint:
    """ Represent an intermediate state of a wavepacket simulation.
    """
    psiR: np.ndarray    # (N1 x N2 x ... x Nel) Wavefunction
    psiK: np.ndarray    # (N1 x N2 x ... x Nel) ND-FFT of psiR
    time: float         # current time
    istep: int          # current step (int)
    backend: ModuleType # numpy/cupy. determines the data types.


def preprocess(potential:Union[Potential,np.ndarray,Callable[[List[np.ndarray]],np.ndarray]], grid:Grid, wavepacket, c0:Union[int,float,complex], M:float, dt:float) -> PhysicalParameter:
    """ Produce things needed for propatate().

    potential: potential.Potential, an (N1 x N2 x ... x Nel) numpy array, or a callable that returns such array.
    grid: A grid instance specifying the actual grid.
    wavepacket: A (N1 x N2 x ... Nn) numpy array, or a function that returns such array by taking position (with size 
        List[array(N1 x ...)]) as the argument. Normalization is not required.
    c0: int/List[float]. Initial surface or amplitude.
    M: mass.
    dt: timestep.
    """

    if isinstance(potential, np.ndarray):
        nel = potential.shape[-1]
        nk = potential.ndim - 2
        H = potential
        assert H.shape[-2] == H.shape[-1]
        assert H.shape[:-2] == grid.shape
    elif isinstance(potential, Potential):
        nel = potential.get_dim()
        nk = potential.get_kdim()
        get_H = potential.get_H
        assert nk == grid.ndim
    else:
        get_H = potential
        nk = grid.ndim

    # build K grid
    r = grid.build_individual()
    k = []
    dA = 1.0
    dK = 1.0
    for j in range(nk):
        dr = r[j][1] - r[j][0]
        k.append(np.fft.fftfreq(grid.shape[j], dr) * 2* np.pi)
        dA *= dr
        dK *= (r[j][-1] - r[j][0]) / (grid.shape[j] - 1) / grid.shape[j]

    R = np.meshgrid(*r, indexing='ij')
    K = np.meshgrid(*k, indexing='ij')
    
    # build H 
    if not isinstance(potential, np.ndarray):
        H = get_H(R)
        if not isinstance(potential, Potential):
            nel = H.shape[-1]

    assert H.shape == tuple(grid.shape + (nel, nel))
    
    # build wavefunction
    Psi = np.zeros(grid.shape + (nel,), dtype=complex)
    
    if isinstance(wavepacket, np.ndarray):
        psi0 = wavepacket
    elif callable(wavepacket):
        psi0 = wavepacket(R)
    else:
        raise ValueError("wavepacket: Either an array or a callable return an array")

    if isinstance(c0, int):
        Psi[..., c0] = psi0
    else:
        c = np.array(c0)
        c /= np.linalg.norm(c)
        for j in range(len(c)):
            Psi[..., j] = psi0 * c[j]

    Psi /= np.sqrt(np.sum(abs2(Psi))* dA)
    assert Psi.shape == tuple(grid.shape + (nel,))

    # build exponential of operators
    KE = sum((K_**2 for K_ in K))/2/M
    TU = np.exp(-1j*dt*KE)
    VU = expm_batch(H, dt)
    VUhalf = expm_batch(H, dt/2)
    VUhalfinv = expm_batch(H, -dt/2)

    return PhysicalParameter(Psi, H, KE, TU, VU, VUhalf, VUhalfinv, R, K, dA, dK, dt)


def propagate(para:PhysicalParameter, nstep:int, output_step:int, *, 
              on_output:list[Callable[[PhysicalParameter, CheckPoint], Any]]=[],
              partitioner=None, partition_titles=None, fixes=None, checkend=False, 
              boundary=None, checkend_rtol:float=0.05, verbose=True, cuda_backend:bool=False, extra_normalize:bool=False) -> list:
    """ The actual propagating function.
    Args:
   
    - nstep: Maximum number of steps.
    - output_step: Step to output info and save result.
    - on_output: list of functions (PhysicalParameter, CheckPoint)->Any. Executed at each output_step. Note the execution result is not automatically collected.
    - partitioner: (depracated) None/list[list[array[float]]->array[bool]]. Each of the functions will be called by p(R), where R is position meshgrid, list with potential.dim() element of size N x N ...
        it should return a boolean map (with size N x N ...). If None, a unit partitioner is used (just a number 1).
    - partition_titles: (depracated) list[str]. Titles for verbose output.
    - fixes: None/list[(R, psi)->any]. Will be called *every step* (including t=0), and the result will be saved. Note that the propagation will be significantly slower, since
        twice calls of exp(-iV*dt/2) has to be invoked instead of a single call of exp(-iV*dt).
    - checkend, checkend_rtol: If true, and sum(abs(boundary(R) * Psi)^2)) > 1 - checkend_rtol, then the simulation is terminated.
    - boundary: list[array[float]]->array[bool]. Return a bool map with shape equals to position grid where True means inside boundary. Invoked when checkend is true.
    - verbose: 
        - If False, remains silent.
        - Otherwise, print time (t), energy (Etot), kinetic energy (KE), total population (Pall), and population of each partition region on each state (P{title}n).
    - cuda_backend: Uses cupy as backend instead of numpy.
    - extra_normalize: Whether the wavepacket is normalized every output_step. Improves long-time stability but may cause unwanted effects.

    Returns: records, or (records, fix_outputs) if any fixes are present.
    - records: A list of [time, population, position, momentum, extra ], each (except extra)
        is array with shape nel x m ( x nk ), where m is determined by partitioner (None -> 1). The collection timestep is same as output_step.
        extra is a list containing the return of each analyzer.
    - fix_outputs: a list of lists. fix_outputs[n][m] means the result of n'th fix at m'th step. (Note the order is different from records).
    """

    Psi = para.Psi; H = para.H; KE = para.KE; TU = para.TU; VU = para.VU; VUhalf = para.VUhalf; VUhalfinv = para.VUhalfinv
    R = para.R; K = para.K; dA = para.dA; dK = para.dK; dt = para.dt
    
    result = []

    partition_filter = [p(R) for p in partitioner] if partitioner else [1]
    boundary_filter = boundary(R) if boundary else 1
    nel = Psi.shape[-1]
    nk = len(Psi.shape) - 1
    
    # using_gpu: translate Psi, H, KE, TU, VU, VUHalf, VUHalfinv, R, K, partition_filter, boundary_filter
    
    if cuda_backend:
        import cupy as cp
        _backend = cp
        Psi = cp.asarray(Psi); H = cp.asarray(H); KE = cp.asarray(KE); TU = cp.asarray(TU)
        VU = cp.asarray(VU); VUhalf = cp.asarray(VUhalf); VUhalfinv = cp.asarray(VUhalfinv)
        R = [cp.asarray(R_) for R_ in R]
        K = [cp.asarray(K_) for K_ in K]
        para = PhysicalParameter(Psi, H, KE, TU, VU, VUhalf, VUhalfinv, R, K, dA, dK, dt)
        partition_filter = [cp.asarray(p) if isinstance(p, np.ndarray) else p for p in partition_filter ]
        boundary_filter = cp.asarray(boundary_filter) if isinstance(boundary_filter, np.ndarray) else boundary_filter

    else:
        _backend = np

    def dot_v(v, p):
        return (v @ p[...,None]).reshape(p.shape)

    if fixes:
        fix_outputs = [[f(R, Psi)] for f in fixes]

    Psi = dot_v(VUhalf, Psi)

    result = []

    if verbose:
        if not partition_titles:
            partition_titles = 'ABCDEFGHIJKLMNOPQ'[:len(partition_filter)]
        print('t\tE\tKE\tTotal', end='')
        print(''.join(('\t%s%d' % (x[1], x[0]) for x in itertools.product(range(nel), partition_titles))))

    for i in range(nstep+1):
        
        if i % output_step == 0:
            if i != 0 and extra_normalize:
                Psi /= (_backend.sum(abs2(Psi))* dA)**0.5

            Psi_output = dot_v(VUhalfinv, Psi)
            Psip = _backend.empty_like(Psi)
            for j in range(nel):
                Psip[...,j] = _backend.fft.fftn(Psi_output[...,j])

            Rhoave = []

            for j in range(nel):
                for pf in partition_filter:
                    abspsi = abs2(Psi_output[...,j]) * pf
                    if cuda_backend:
                        Rhoave.append(_backend.sum(abspsi).get() * dA)
                    else:
                        Rhoave.append(_backend.sum(abspsi) * dA)

            for f in on_output:
                f(para, CheckPoint(Psi_output, Psip, i*para.dt, i, _backend))

            Rhotot = _backend.sum(abs2(Psi_output)) * dA
            KEave = _backend.sum(abs2(Psip) * KE[...,None]) * dK
            Eave = KEave + _backend.vdot(Psi_output, dot_v(H, Psi_output)).real * dA

            result.append((i*dt, 
                np.array(Rhoave).reshape((nel, len(partition_filter))), 
                ))

            if verbose:
                print('%.8g\t%.8g\t%.8g\t%.8g' % (i*dt, Eave, KEave, Rhotot), end='')
                print(''.join(('\t%.8g' % x for x in Rhoave)))

            if checkend and _backend.sum((boundary_filter * _backend.sum(abs2(Psi), axis=-1))) < (1 - checkend_rtol)*_backend.sum(abs2(Psi)):
                break

        for j in range(nel):
            Psi[...,j] = _backend.fft.ifftn(_backend.fft.fftn(Psi[...,j])*TU)
            
        if fixes:
            Psi = dot_v(VUhalf, Psi)
            for f, o in zip(fixes, fix_outputs):
                o.append(f(R, Psi))
            Psi = dot_v(VUhalf, Psi)
        else:
            Psi = dot_v(VU, Psi)

    return result if not fixes else (result, fix_outputs)
